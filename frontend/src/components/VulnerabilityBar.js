import React, {Component} from "react";
import {findDOMNode} from "react-dom";
import {greenAndRed} from "../styles";
import {toolTipGenerator} from "../utils";

const d3 = require("d3");

export default class VulnerabilityBar extends Component {
    constructor(props) {
        super(props);
    }

    componentDidMount = () => {
        const {dataset} = this.props;
        const baseId = "bar-chart-base-" + dataset.remove_id;
        const thisDOM = findDOMNode(this);
        let baseGroup = d3.select(thisDOM).select("#" + baseId);
        this.renderSvg(baseGroup, this.props);
    };

    shouldComponentUpdate = () => false;

    UNSAFE_componentWillReceiveProps = nextProps => {
        const {updateMessage} = nextProps;
        if (
            updateMessage === "init" ||
            updateMessage === "updateVisibleSize" ||
            updateMessage === "updateBrushRange" ||
            updateMessage === "changeStateID"
        ) {
            this.updateCanvas(this.props, nextProps);
        }
    };

    updateCanvas(currentProps, nextProps) {
        const currentBaseId = "bar-chart-base-" + currentProps.dataset.remove_id;
        const thisDOM = findDOMNode(this);
        const svgRoot = d3.select(thisDOM);
        let baseGroup = d3.select(thisDOM).select("#" + currentBaseId);
        baseGroup.remove();

        const futureBaseId = "bar-chart-base-" + nextProps.dataset.remove_id;
        baseGroup = svgRoot.append("g").attr("id", futureBaseId);
        this.renderSvg(baseGroup, nextProps);
    }

    renderSvg(svg, props) {
        const {
            canvasHeight,
            canvasWidth,
            dataset,
            visibleSize,
            rankInfluenceRange
        } = props;
        const margin = {top: 10, right: 10, bottom: 5, left: 10};
        const height = canvasHeight * 0.95;
        //parentDom.offsetHeight * 0.95;
        let data = dataset.remove_res;
        data.sort((a, b) => {
            if (Math.abs(a.rank_change) < Math.abs(b.rank_change)) {
                return 1;
            } else if (Math.abs(a.rank_change) > Math.abs(b.rank_change)) {
                return -1;
            } else {
                return Math.abs(a.node_id) < Math.abs(b.node_id) ? 1 : -1;
            }
        });

        const width = canvasWidth * 0.95;

        let y = d3
            .scaleLinear()
            .domain([0, rankInfluenceRange])
            .range([Number(height) - Number(margin.bottom), margin.top]);

        data = data.slice(0, visibleSize);
        let x = d3
            .scaleBand()
            .domain(data.map(d => d.node_id))
            .range([margin.left, width - margin.right])
            .padding(0.2);

        let xAxis = g =>
            g
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickSizeOuter(0));

        // let yAxis = g =>
        //   g
        //   .attr("transform", `translate(${margin.left},0)`)
        //   .call(d3.axisLeft(y))
        //   .call(g => g.select(".domain").remove());

        const tooltip = toolTipGenerator("#left-panel");

        // gridlines in x axis function
        function make_x_gridlines() {
            return d3.axisBottom(x).ticks(10);
        }

        // gridlines in y axis function
        function make_y_gridlines() {
            return d3.axisLeft(y).ticks(10);
        }

        // add the X gridlines
        svg
            .append("g")
            .attr("class", "grid")
            .style("opacity", 0.1)
            .attr(
                "transform",
                "translate(0," + (Number(height) - Number(margin.bottom)) + ")"
            )
            .call(
                make_x_gridlines()
                    .tickSize(-height + margin.bottom + margin.top)
                    .tickFormat("")
            );

        // add the Y gridlines
        svg
            .append("g")
            .attr("class", "grid")
            .attr("transform", "translate( " + margin.left + ",0)")
            .style("opacity", 0.1)
            .call(
                make_y_gridlines()
                    .tickSize(-width + margin.right + margin.left)
                    .tickFormat("")
            );

        svg
            .append("g")
            .selectAll("rect")
            .data(data)
            .join("rect")
            .style("mix-blend-mode", "multiply")
            .attr("x", d => x(d.node_id))
            .attr("y", d => y(Math.abs(d.rank_change)))
            .attr("height", d => height - margin.bottom - y(Math.abs(d.rank_change)))
            .attr("width", x.bandwidth())
            .attr("fill", d => {
                if (d.rank_change > 0) {
                    return greenAndRed[0];
                } else if (d.rank_change < 0) {
                    return greenAndRed[1];
                } else {
                    return "#bdbdbd";
                }
            })
            .on("mousemove", function (d) {
                tooltip
                    .style("left", d3.event.pageX - 50 + "px")
                    .style("top", d3.event.pageY - 60 + "px")
                    .style("display", "inline-block")
                    .html(() => {
                        if (d.rank_change > 0) {
                            return (
                                "Node #" +
                                d.node_id +
                                "<br>" +
                                "<span style='color:" +
                                greenAndRed[0] +
                                "'>" +
                                "Rank increase " +
                                Math.abs(d.rank_change) +
                                "</span>"
                            );
                        } else if (d.rank_change < 0) {
                            return (
                                "Node #" +
                                d.node_id +
                                "<br>" +
                                "<span style='color:" +
                                greenAndRed[1] +
                                "'>" +
                                "Rank decrease " +
                                Math.abs(d.rank_change) +
                                "</span>"
                            );
                        } else {
                            return "Node #" + d.node_id + "<br>" + "Rank unchanged";
                        }
                    });
            })
            .on("mouseout", function (d) {
                tooltip.style("display", "none");
            });

        // const axis = svg.append("g").call(xAxis);
        // axis.selectAll("text").remove();
        // svg.append("g").call(yAxis);
    }

    render() {
        const {dataset, canvasHeight, canvasWidth} = this.props;
        const svgId = "bar-chart-" + dataset.remove_id;
        const baseId = "bar-chart-base-" + dataset.remove_id;
        return (
            <svg id={svgId} style={{height: canvasHeight, width: canvasWidth}}>
                <g id={baseId} style={{height: "100%", width: "100%"}}/>
            </svg>
        );
    }
}
